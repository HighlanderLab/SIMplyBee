---
title: "SIMplyBee - Colony events"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ColonyEvents}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options:
   markdown:
     wrap: 80
     canonical: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  include = TRUE
)
```

# Introduction

This vignette will introduce you to colony events. We implemented the most
important natural events like swarming, supersedure, and collapse of the colony,
and a beekeeping management practice called splitting. All functions that
implement colony events work both on `Colony` and `MultyColony` objects.

# Swarming

Swarming is the process in which honeybee colonies reproduce to form new
colonies. When a honeybee colony outgrows its hive, becomes too congested, or
too populated for the queen's pheromones to spread among workers, then the
swarming begins. The workers start building swarm cells for new virgin queens.
When the queen is ready, she leaves the hive and is followed by about 70% of the
workers in a massive cloud of flying bees, the swarm (Rangel et al., 2012). The
swarm will cluster on a nearby tree and the remain there until they find a
suitable new home.

The virgin queens developing in the old hive are daughters of the queen that
swarmed and are attended by the remnant workers that did not leave with the
swarm. After few days, the new virgin queens begin to emerge. Typically, the
first queen to emerge will kill the rest of virgin queens to assume the role as
the new queen for the colony. She will then go on a mating flight to find drones
to mate with to begin laying eggs and rebuilding the workforce in the colony
(Clemson Cooperative Extension, 2021; Rangel et al., 2012)

In the simulation, we first need to initiate a simulation with 10 base virgin
queens. We next create a colony (`Colony` class) and an apiary (`MultiColony`
class).

```{r create founder genoms and a Colony and Multicolony objects }
founderGenomes <- quickHaplo(nInd = 30, nChr = 1, segSites = 100)
SP <- SimParamBee$new(founderGenomes)
basePop <- createVirginQueens(founderGenomes)
drones <- createDrones(basePop[1], n = 1000)
fatherGroups <- pullDroneGroupsFromDCA(drones, n = 30, nDrones = 10)

# Create Colony and MultiColony class
colony <- createColony(x = basePop[2])
colony <- cross(colony, drones = fatherGroups[[1]])
colony <- buildUp(colony, nWorkers = 100, nDrones = 20)

apiary <- createMultiColony(basePop[3:8], n = 6)
apiary <- cross(apiary, drones = fatherGroups[2:7])
apiary <- buildUp(apiary, nWorkers = 100, nDrones = 20, exact = TRUE)
```

We developed a function `swarm()` that simulates swarming. The function takes a
`Colony` class object and a percentage `p` of workers that leave with the swarm.
The function returns is a list with two `Colony` clas objects, `swarm` and
`remnant`. The `swarm` contains the old queen and `p` percentage of workers that
left the hive. The `remnant` contains the rest of workers `(1-p)`, all the
drones, and virgin queens that are daughters of the old queen that swarmed.

Let's swarm our `colony`. Since the output of a function is a list with
colonies, we must save it in a new (temporary) object.

```{r swarm colony }
tmp <- swarm(colony, p = 0.4)
tmp
```

The function returns two colonies: `remnant` and `swarm`. The `remnant` colony
does not have queen but has one virgin queen that must be mated. It also has 60
workers since we set `p` argument to 0.4 meaning that 40% of workers will leave
with the swarm. All the drones remained in the `remnant` and `Has swarmed` has
turned to `TRUE`.

The `swarm` contains the old queen, no virgin queens, and 40 workers, since we
set the proportion `p` to 0.4. Same as in the `remnant`, the `Has swarmed` has
turned to `TRUE` in the `swarm`.

The `swarm` stays genetically identical to the "old" colony, although downsized.
Hence, we assign the `swarm` back to the original colony. The `remnant` has a
new queen is hence genetically different from the original colony. Thus, we
considered it to be a new colony.

```{r saving output of the function}
colony <- tmp$swarm
colony1 <- tmp$remnant
colony <- buildUp(colony)
```

After swarming, the colony would usually build-up back to the full size and the
virgin queens would mate.

Instead of setting the `p` everytime we call the `swarm()` function, we can save
the `swarmP` argument in the `SimParamBee` object. The `swarm()` function will
then use this percentage if `p` is not set.

```{r inspect the p swarm parameter in SP object}
SP$swarmP
```

The default value is 0.5, but we can set any value we want.

```{r set our own swarmP in SP object}
SP$swarmP <- 0.35
SP$swarmP
```

We swarm a `MultiColony` object is the same was we swarm a single `Colony` -
with the `swarm()` function. The `swarm()`function is here applied to each
colony in the `MultiColony()` object with the same parameters. The function now
returns two `MultiColony()` objects - one containing the `swarms` and the other
containing the `remnants`.

```{r swarming MultyColony}
tmp <- swarm(apiary)
tmp
```

We see that we get six swarms and six remnants from the apiary with six
colonies. We can inspect individuals colonies to ensure they swarmed according
to the parameters. Let's inspect the `swarm` and `remnant` of the third colony.

```{r inspect the output (swarm)}
tmp$swarm[[3]]
```

```{r inspect the output (remnant)}
tmp$remnant[[3]]
```

We see that the the third colony was swarmed with `p` of 35% as specified in the
`SimParamBee`, hence the swarm left with 35 workers and the old queen and the
remnant stayed with a new virgin queen and 65 workers.

Above, all the colonies in a `MultiColony` are swarmed with the same percentage.
However, we can also specify a different `p` for each colony.

```{r swarmed MultyColony object with different swarm p}
tmp <- swarm(apiary, p = c(0.3, 0.4, 0.5, 0.6, 0.7, 0.8))
```

If we now inspect the first and the second swarm, we see that each colony has a
different percentage of workers that stayed and left

If you want to track the genetics, you would assign the swarms back to the
original apiary and create a new apiary from the remnant. However, if you want
to track the position, the remnant actually stay in the same position and would
hence be assigned back to the same apiary, while the swarm would be assigned to
a new apiary or be lost.

You can also use a non-fixed `p` parameter by using the function `swarmPUnif`
that samples the `p` from a uniform distribution between values 0.4 and 0.6
irrespective of colony strength.

```{r assign swarm back to apiary and build up the apiary}
apiary <- tmp$swarm
apiary <- buildUp(apiary)
```

# Splitting

Colony splitting is a common beekeeping technique for managing swarming. A
percentage of workers, brood, and food stores are removed and combined in a new
colony. Old queen normally stays with split colony (remnant in our function).
Function works on `Colony` and `Multicolony` objects. Argument `p` is proportion
of workers that will go to new colony. The output of the function is a list of
two `Colony` or `MultiColony` objects.

```{r split a colony}
tmp <- split(colony, p = 0.3)
colony <- tmp$remnant
colony
```

We see that in remnant is old queen (ID 2), and 70% of workers since we set `p`
argument to 0.3 meaning that 30% is removed to split. `Has split` is turned to
`TRUE`.

```{r build up the colony}
colony <- buildUp(colony)
```

```{r inspect the split}
tmp$split
```

`p` argument can be also put in `SP` object, so we do not specify it each time
we call the function. We call `SimParamBee$splitP` and assign new `p` argument
in the `SP` object. In the split we have 30% of workers and a virgin queen.
`Has split` is turned to `TRUE`. `p` argument can be used as it is demonstrated
in `swarm` function. We can specify a vector with different values when spliting
`MultiColony` object.

```{r split the MultiColony object and inspect the first colony in remnant}
tmp <- split(apiary, p = 0.3)
tmp$remnant[[1]]
```

Now we see that in remnant we have mated queen and 70 workers...

```{r inspect the split of the first colony}
tmp$split[[1]]
```

and a virgin queen with 30 workers in split. We can use the vector of `p`,
different for each colony same as in `swarm()` function.

```{r build up the colony and apaiary for further examples}
apiary <- tmp$remnant
apiary <- buildUp(apiary)
```

# Supersedure

Supersedure is a replacement of a queen by her daughter without interference of
beekeeper. Supersedure is a natural way of requeening without swarming. There
are many reasons for supersedure: poor physical condition of a queen, old age,
diseases, depleted spermatheca, poorly bread queen, reduced pheromone output and
many others (Hamdan, 2010).

```{r inspect the colony}
colony
```

```{r supersede Colony object}
colony <- supersede(colony)
colony
```

Now, the old queen is removed and virgin queen ready to mate. We also see that
`Has superseded` event is set to `TRUE`. The function `supersede()` works both
on `Colony` and `MultiColony` classes. We can select percentage of colonies from

```{r supersede Multicolony object}
apiary <- supersede(apiary)
apiary[[2]]
```

We do the supersedure of `MultiColony` in a same way as it is described as
described above in `Colony` . We don't have to assign the output of the function
to a special object since the output is single `Colony` or `MultiColony` object
and not a list of two.

# Collapse

Collapse of the colony is a term that describes death of a colony. All
individuals within a colony die when collapse occurs. There are many reasons for
collapse of a honey bee colony like: diseases, starvation, queen problems,
environmental and in-hive contamination with pesticides. Colony losses can be
very high, up to 60% of colonies per year. High colony losses can significantly
influence genetic structure of a population.

```{r create the colony and Mlticolony }
colony <- createColony(x = basePop[20])
colony <- cross(colony, drones = fatherGroups[[20]])
colony <- buildUp(colony, nWorkers = 100, nDrones = 20)

apiary <- createMultiColony(basePop[21:26], n = 6)
apiary <- cross(apiary, drones = fatherGroups[21:26])
apiary <- buildUp(apiary, nWorkers = 100, nDrones = 20, exact = TRUE)
```

```{r collapse the colony}
colony <- collapse(colony)
colony
```

The output of the function is `Colony` with the `Has collapsed` set to `TRUE`.

```{r collapse the MultiColony}
apiary <- collapse(apiary)
apiary[[3]]
```

The function works also `MultiColony` objects. Colonies from `MultiColony` are
selected by using function `pullColonies()` with arguments `n` specifying exact
number of collapsed colonies or with `p` argument specifying the percentage of
collapsed colonies. `collapse()` function is used when you want to keep
collapsed colonies for subsequent genetic analysis. In case when you don't need
the collapsed colony you can simply select the survivors with `select()`
function.

# References

Clemson Cooperative Extension. (2021). Frequently asked questions about honey
bee swarms.
\<<https://hgic.clemson.edu/factsheet/frequently-asked-questions-about-honey-bee-swarms/>,
accesed on 11.11.2022).

Hamdan K. (2010). Natural Supersedure of Queens in Honey Bee Colonies. Bee
World, 87(3), 52-54.

Rangel J., Seeley T. D. (2012). Colony fissioning in honey bees: size and
significance of the swarm fraction. Insectes sociaux, 59(4), 453-462.

