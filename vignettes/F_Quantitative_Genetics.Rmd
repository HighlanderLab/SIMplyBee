---
title: "SIMplyBee - Quantitative genetics"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SIMplyBee - Quantitative genetics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  include = TRUE
)
```

# Introduction

This vignette describes and demonstrates how SIMplyBee implements quantitative
genetics principles for honeybees. Specifically, it describes three different
examples where we simulate:

  1. Honey yield - a single colony trait,
  
  2. Honey yield and Calmness - two colony traits,
  
  3. Colony strength and Honey yield - two colony traits where one trait impacts
     the other one via the number of workers, and


```{r load_packages}
library(package = "SIMplyBee")
library(package = "ggplot2")
```

We start by simulating some honeybee founder genomes with 16 chromosomes and 1000 segregating sites per chromosome.
```{r founderGenomes}
# Founder genomes
founderGenomes <- quickHaplo(nInd = 20, nChr = 16, segSites = 1000)
```

# Honey yield
AlphaSimR, and hence SIMplyBee, simulate each individuals with its corresponding genome and quantitative genetic and phenotypic values. To this end we need to set quantitative genetic parameters for the traits we want to simulate in the `simParamBee` object at the beginning of the simulation. We need to set the number of traits we want to simulate, the number of quantitative trait loci (QTL) that affect the trait, the distribution of QTL effect, the mean of the trait and the genetic and environmental variances. If we simulate multiple traits, we also need to specify the genetic and environmental covariances between the traits. In honeybees, the majority of the traits includes a queen and worker effect. The queen effect is usually the indirect genetic effect, since the queen does not perform tasks herself but instead lays the eggs and managed the hive through pheromones. The worker effect is usually the direct genetic effect since workers do the actual work - bring the nectar, clean the hive etc. The queen and worker effect for a trait are usually negatively correlated in honeybees. 
Here, we simulate two traits that represent the queen and worker effect for honey yield. We set the mean of the queen effect to 20 with variance of 1, and the mean of the worker effect to 1 with variance 1/noWorkers. The mean and variance for the queen effect are larger than for the worker effect, since there is one queen and many workers the effect of which accumulate. 

```{r SimParamBee}
# Global simulation parameters
SP <- SimParamBee$new(founderGenomes)

# Quantitative genetic parameters - for a single colony trait that is impacted
# by queen and worker genetic effects - each represented by a different trait
mean <- c(20, 0)
varA <- c(1, 1 / SP$nWorkers)
```

We set the genetic covariance between the traits to -0.5 to reflect the usual negative correlation or the queen and worker effect. We add an additive trait to `simParamBee` with `addTraitA` function and we name them `queenTrait` and `workerTrait`. For more options on simulating traits read AlphaSimR's document here: https://cran.r-project.org/web/packages/AlphaSimR/vignettes/traits.pdf.
```{r SimParamBee}
corA <- matrix(data = c( 1.0, -0.5, 
                        -0.5,  1.0), nrow = 2, byrow = TRUE)
SP$addTraitA(nQtlPerChr = 100, mean = mean, var = varA, corA = corA,
             name = c("queenTrait", "workersTrait"))
```

We set the environmental variance of the queen effect to 3 and of worker effect to 3/nWorkers. We set the environmental correlation between the queen and worker effect to 0.3.
```{r SimParamBee}
varE <- c(3, 3 / SP$nWorkers)
# TODO: what is a reasonable environmental correlation between queen and worker effects?
corE <- matrix(data = c(1.0, 0.3, 
                        0.3, 1.0), nrow = 2, byrow = TRUE)
SP$setVarE(varE = varE, corE = corE)
```

We continue by creating a base population. Since we defined two traits in the `SimParamBee`, all the newly created individuals get a corresponding genetic and phenotypic value for the traits. The genetic values are stored in the `gv` slot of a `Pop` object, and phenotypic values in the `pheno` slot.
```{r basePop_virgin_queens}
# Base population virgin queens
basePop <- createVirginQueens(founderGenomes, n = 20)
head(basePop@gv)
# TODO: We lose trait names in createVirginQueens() #404
#       https://github.com/HighlanderLab/SIMplyBee/issues/404
head(basePop@pheno)
hist(basePop@pheno[, "queenTrait"])
hist(basePop@pheno[, "workersTrait"])
```

In SIMplyBee, all individual get a corresponding genetic and phenotypic values. That holds also for drones, although for honey yield (any many other traits) we are usually not interested in their contribution and their phenotypic values.

```{r basePop_drones}
# Base population drones
drones <- createDrones(x = basePop[1:5], nInd = 3)
head(drones@pheno)
```
We continue by creating a colony and crossing the queen within it and add some workers. We add only a small number of workers to facilitate the inspection of the results.
```{r create_colony}
# Colony
colony <- createColony(x = basePop[6])
colony <- cross(x = colony, drones = drones)
colony <- addWorkers(colony, nWorkers = 10)
colony
```

We can acces the genetic and phenotypic values of the colony member with functions `getGv()` and `getPheno()`, both of which take the `caste` as an argument. The `caste` could be `queen`, `fathers`, `virginQueens`, `workers`, `drones`, or `all`. The latter returns the value for all colony members either by caste or as a single dataframe if `collapse` argument if set to `TRUE`. 
```{r create_colony}
getGv(colony, caste = "queen")
head(getGv(colony, caste = "workers"))
head(getGv(colony, caste = "all", collapse = TRUE))

getPheno(colony, caste = "queen")
head(getPheno(colony, caste = "workers"))
head(getPheno(colony, caste = "all", collapse = TRUE))
```

We also included shortcuts for accessing the genetic and phenotypic values of a specific caste directly.
```{r}
getQueenGv(colony)
head(getWorkersGv(colony))

getQueenPheno(colony)
head(getWorkersPheno(colony))
```
Some phenotypes, such as honey yield, would only be expressed if the colony is at its full-size. The full-size of the colony in the simulation does not have to be the same as in real life, but is defined by the user instead. The `buildUp()` function assumes we are building the colony to a full size and hence turns the `production` status of the colony to `TRUE`. SIMplyBee includes a function `Ã¬sProductive()` to check the production status of a colony. Since we have previously build-up our colony, the colony is productive.
```{r build_up_colony}
# Check if colony is productive
isProductive(colony)

# Build-up the colony and check the production status again
colony <- buildUp(colony)
isProductive(colony)
```
We now combine colony values into a single dataframe.

```{r data.frame}
# Collate genetic and phenotype values of workers
df <- data.frame(id = colony@workers@id,
                 father = colony@workers@father,
                 gvQueenTrait = colony@workers@gv[, "queenTrait"],
                 gvWorkersTrait = colony@workers@gv[, "workersTrait"],
                 pvQueenTrait =  colony@workers@pheno[, "queenTrait"],
                 pvWorkersTrait = colony@workers@pheno[, "workersTrait"])
head(df)
```
We then plot the covariance between the queen and worker effect that visualises a negative correlation between these effects in a population.
```{r plot_queen_vs_worker_values}
# Covariation between queen and worker trait genetic values in workers
p <- ggplot(data = df, aes(x = gvQueenTrait, y = gvWorkersTrait)) +
  geom_point() +
  theme_classic()
print(p)
```
Since we know the genetic values of all the individuals, we also know what each of the fathers brought to the colony,
```{r fathers_values}
# Variation in patriline genetic values
getFathersGv(colony)
```

Due to the information above, we can also plot the distribution of genetic values by the patriline (workers offspring of a single drone) for the queen effect. We see clear differences between the partilines (21 - 35).
```{r distribution_by_patriline}
# Variation in worker genetic values by patriline - for queen trait
p <- ggplot(data = df, aes(x = gvQueenTrait, colour = father)) +
  geom_density() +
  theme_classic()
print(p)
```
We can do the same for the worker effect.
```{r distribution_by_patriline_2}
# Variation in worker genetic values by patriline - for workers trait
p <- ggplot(df, aes(x = gvWorkersTrait, colour = father)) +
  geom_density() +
  theme_classic()
print(p)
```


However, in honeybees we usually don't observe values on an individual level, but colony level instead. SIMplyBee includes functions for mapping individual values to the colony value. The general function for combining individual-level values in a single colony-level value is the `calcColonyValue()` function that can be used to combine any quantitative value. However, computation of some values, such as breeding value, dominance deviations, and epistatic deviations, is complex in honeybees and could be misinterpreted. Hence, here we focus only on computing the genetic and phenotypic values. SIMplyBee contains shortcuts for computing these values names `calcColonyPheno()` and `calcColonyGv()`. These functions require the user to specify so called mapping functions (`FUN` argument). The mapping function required specifying which are the queen, worker, and potentially also the drone trait and what function we want to apply to each of them before combining. We also need to provide the function to combine these (transformed) queen, worker, and potentially drone trait into a single value. We can also specify, whether the colony value depends on the production status. That is, if the colony is not productive, there is no value to express. In SIMplyBee, we provide default mapping functions, `mapCasteToColonyValue` that can be modified to cater user's and trait's needs.

DAG - figure from Laura
We now compute a single phenotypic value for our colony. In reality, this would be the value that you are able to collect. In this case, a single value for honey yield per colony.
```{r colony_pheno} 
# Colony phenotype value
calcColonyPheno(colony, queenTrait = "queenTrait", workersTrait = "workersTrait")
help(calcColonyPheno)
help(mapCasteToColonyPheno)
```
The same functions can be used on a `MultiColony` object. Let's create a `MultiColony` object that represents our apiary.
```{r}
apiary <- createMultiColony(basePop[7:20])
drones <- createDrones(basePop[1:5], nInd = 100)
droneGroups <- pullDroneGroupsFromDCA(drones, n = nColonies(apiary), nDrones = 15)
apiary <- cross(apiary, droneGroups)
apiary <- buildUp(apiary)
```

We can extract the genetic and phenotypic values in the same manner than from a colony with `get*Gv()` and `get*Pheno()` functions. The output of the function is a names list with values for each colony or a single data frame if `collapse` is `TRUE`. 
```{r}
head(getQueenGv(apiary))
head(getWorkersGv(apiary, collapse = TRUE))
```
In a similar manner, we can compute colony value for all the colonies in our apiary, where the row names of the output represent colony IDs. We can compute either colony-level genetic or phenotypic values.
```{r}
colonyValuesGv <- calcColonyGv(apiary, FUN = mapCasteToColonyGv, checkProduction = TRUE)
colonyValuesPheno <- calcColonyPheno(apiary, FUN = mapCasteToColonyPheno, checkProduction = TRUE)
```

Since the aim of selection is to select the best individuals or colonies for the reproduction, we could select the best colony in our apiary based on either genetic or phenotypic value for grafting the new generation of queens. The colony with the highest genetic value is colony with ID 6, hence we select it for further reproduction.
```{r}
colonyValuesGv
bestGvColony <- selectColonies(apiary, ID = 6)
```


# Honey yield and Calmness
Now, let's see how to two uncorrelated traits, honey yield and calmness. For each of them, we follow the recipe from above and simulate a queen and worker effect. We set the genetic covariance between the queen and worker effect for honey yield to -0.5 and for calmness to -0.4, and environmental covariance between the effects to 0.3 for honey yield and 0.2 for calmness. We assume no genetic or environmental correlation between the honey yield and calmness.

```{r SimParamBee_2}
# Global simulation parameters
SP <- SimParamBee$new(founderGenomes)

# Quantitative genetic parameters - for two traits with queen and worker genetic effects
# TODO: what is the scale of calmness "values"?
meanP <- c(20, 0, 0, 0)
# TODO: revise covariances (I made them up!)
varA <- c(1, 1 / SP$nWorkers, 1, 1 / SP$nWorkers)
corA <- matrix(data = c( 1.0, -0.5, 0.0, 0.0, 
                        -0.5,  1.0, 0.0, 0.0,
                         0.0,  0.0, 1.0, -0.4, 
                         0.0,  0.0, -0.4, 1.0), nrow = 4, byrow = TRUE)
SP$addTraitA(nQtlPerChr = 100, mean = meanP, var = varA, corA = corA,
             name = c("yieldQueenTrait", "yieldWorkersTrait",
                      "calmQueenTrait", "calmWorkersTrait"))

# TODO: revise covariances (I made them up!)
varE <- c(3, 3 / SP$nWorkers, 3, 3 / SP$nWorkers)
corE <- matrix(data = c(1.0, 0.3, 0.0, 0.0,
                        0.3, 1.0, 0.0, 0.0,
                        0.0, 0.0, 1.0, 0.2,
                        0.0, 0.0, 0.2, 1.0), nrow = 4, byrow = TRUE)
SP$setVarE(varE = varE, corE = corE)
```

We continue by creating a base population, and an apiary with 10 full size colonies.
```{r base_pop_and_colony}
basePop <- createVirginQueens(founderGenomes)
drones <- createDrones(x = basePop[1:5], nInd = 100)
apiary <- createMultiColony(basePop[6:15])
droneGroups <- pullDroneGroupsFromDCA(drones, nColonies(apiary), nDrones = 20)
apiary <- cross(x = apiary, drones = droneGroups)
apiary <- buildUp(apiary)
apiary
```
We can again inspect the phenotypic values of all individuals in the apiary with `get*Pheno()` functions. Now, the output contains four simulated traits representing the queen and worker effect for honey yield and calmness. These functions also take an `nInd` argument to sample the desired number of individuals and their values.
```{r}
head(getQueenGv(apiary))
getWorkersPheno(apiary, nInd = 3)
```
Now, we compute the colony genetic phenotypic values for all colonies in the apiary. Since we are simulating two trait, honey yield and calmness, we have to provide a mapping function for each of them.
```{r colony_pheno_2}
calcMyColonyPheno <- function(colony) {
  yield <- mapCasteToColonyPheno(colony,
                                 queenTrait = "yieldQueenTrait",
                                 workersTrait = "yieldWorkersTrait",
                                 traitName = "yield",
                                 checkProduction = TRUE)
  calmness <- mapCasteToColonyPheno(colony,
                                    queenTrait = "calmQueenTrait",
                                    workersTrait = "calmWorkersTrait",
                                    traitName = "calmness",
                                    checkProduction = FALSE)
  return(cbind(yield, calmness))
}
colonyValues <- as.data.frame(calcColonyPheno(apiary, FUN = calcMyColonyPheno))
colonyValues
```
Again, we can now select the best colony based on the best phenotypic value for either yield, calmness or an index of both. Let's say both traits are equally important so we select on a sum of both of them (equivalent to an index with weights of 0.5). (The problem is they are not standardized and don't have equal means!)
```{r}
colonyValues$Index <- colonyValues$yield + colonyValues$calmness
colonyValues
```
We see that based on yield alone, we would select colony 7 for further reproduction, based on calmness alone, we would select colony 2, and based on the index of both traits, we would select colony 5.

# Strength and honey yield

Now, let's simulate two traits where the phenotype of the first one affects the phenotype of the second one. Here we will show how to use `nWorkers` function to genetically and environmentally influence the colony strength and with this honey yield.

TODO: describe which trait is which (nWorkersColonyPhenotype has queenTrait = 1!)

TODO: say more and show some equations

say that this is just an example assuming that workers don't contribute to how many eggs a queen lays phenotypically!

We follow the same logic as above and simulate two traits again - one representing queen's fecundity, that is colony strength, and the other one representing honey yield. The idea is that the higher the fecundity, the more honey yield due to a larger number of workers. We assume that fecundity is only controled by the queen (and not the workers), hence we simulate only queen effect for it. We again assume that honey yield is affected by the workers and how hard they work as well as how well the queen managed the hive, hence we simulate the queen and the worker effect for it.
```{r SimParamBee_3}
# Global simulation parameters
SP <- SimParamBee$new(founderGenomes)

# Quantitative genetic parameters
# - the first trait has only the queen effect
# - the second trait has both queen and workers effects
mean <- c(100, 20, 0)
# TODO: revise covariances (I made them up!)
varA <- c(100, 1, 1 / mean[1]) # mean[1] will be average nWorkers
corA <- matrix(data = c(1.0,  0.0,  0.0,
                        0.0,  1.0, -0.5, 
                        0.0, -0.5,  1.0), nrow = 3, byrow = TRUE)
SP$addTraitA(nQtlPerChr = 100, mean = mean, var = varA, corA = corA,
             name = c("fecundityQueenTrait", "yieldQueenTrait", "yieldWorkersTrait"))

# TODO: revise covariances (I made them up!)
varE <- c(300, 3, 3 / SP$nWorkers)
corE <- matrix(data = c(1.0, 0.0, 0.0,
                        0.0, 1.0, 0.3,
                        0.0, 0.3, 1.0), nrow = 3, byrow = TRUE)
SP$setVarE(varE = varE, corE = corE)
```

We continue by creating an apiary with 10 full-size colonies.
```{r base_pop_and_colony_2}
basePop <- createVirginQueens(founderGenomes)
drones <- createDrones(x = basePop[1:5], nInd = 100)
apiary <- createMultiColony(basePop[6:15])
droneGroups <- pullDroneGroupsFromDCA(drones, nColonies(apiary), nDrones = 20)
apiary <- cross(x = apiary, drones = droneGroups)
```

We next build-up the colonies in the apiary. But instead of building them all up to the same fixed numbers of workers and drones, we build them up according to queen's fecundity. For that we use the sampling function `nWorkersColonyPhenotype`, that computes the number of workers based on the simulated `fecundityQueenTrait`. Each colony hence contains a different number of workers. 
```{r colony_strength}
apiary <- buildUp(apiary, nWorkers = nWorkersColonyPhenotype,
                  queenTrait = "fecundityQueenTrait")
nWorkers(apiary)
help(nWorkersColonyPhenotype)
```
To compute the colony value for the yield, we again employ the `calcColonyValue()` function. Here, we compute the phenotype of the colonies in the apiary with `calcColonyPheno()` function.
```{r colony_pheno_3}
calcMyColonyPheno <- function(colony) {
  yield <- mapCasteToColonyPheno(colony,
                                 queenTrait = "yieldQueenTrait",
                                 workersTrait = "yieldWorkersTrait")
  return(matrix(yield))
}
colonyValuesPheno <- calcColonyPheno(apiary, FUN = calcMyColonyPheno)
colonyValuesPheno
```
We again see that the colony with the best phenotype is colony with ID 9 and we would want to select it for further reproduction, let's say a 1000 new virgin queens.
```{r}
bestColony <- selectColonies(apiary, ID = 9)
newQueens <- createVirginQueens(bestColony, nInd = 1000)
```

