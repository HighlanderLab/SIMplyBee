---
title: "SIMplyBee - Honeybee biology"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{HoneybeeBiology}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options:
   markdown:
     wrap: 80
     canonical: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  include = TRUE
)
```

# Introduction

This vignette introduces SIMplyBee package by describing and demonstrating how
SIMplyBee implements honeybee biology. Specifically, it describes:

1.  Initiating simulation with founder genomes and simulation parameters,

2.  Creating and building up a colony,

3.  Colony structure,

4.  Sex and caste,

5.  Complementary sex determining (csd) locus, and

6.  Inheritance system.

Now load the package and dive in!

```{r load package}
library(package = "SIMplyBee")
```

TODO: Say something about the image (covering 1-4) and how you can use it as a
guide?

TODO: add colony creation image - not working yet \#
knitr::include_graphics("\~/Desktop/GitHub/SIMplyBee/SIMplyBee/vignettes/images/founderpop_diagram2.pdf",
auto_pdf = getOption("knitr.graphics.auto_pdf",FALSE))

# Initiating simulation with founder genomes and global parameters,

We initiate the simulation by simulating founder honeybee genomes. We can
quickly generate genomes using AlphaSimR's `quickHaplo()` or with SIMplyBee's
`TODO()` with appropriate honeybee genome parameters and demography. We will use
`quickHaplo()` and simulate genomes of two founding individuals. In this
example, the genomes will be represented by only three chromosomes and 1000
segregating sites per chromosome. Honeybees have 16 chromosomes and far more
segregating sites per chromosome, but we want a quick simulation here.

```{r founder genomes}
founderGenomes <- quickHaplo(nInd = 2, nChr = 3, segSites = 100)
```

Now we are ready to setup global simulation parameters using `SimParamBee`.
`SimParamBee` enables the user to tweak many simulation settings, which you can
read about in the help pages (`help(SimParamBee)` and `help(SimParam)`). Here we
will point out that we recommend saving this object with the name `SP`. Namely,
all SIMplyBee functions will use this object, if you don't directly specify
`simParamBee` argument.

```{r SimParamBee}
SP <- SimParamBee$new(founderGenomes)
```

There are many options provided by `SimParamBee` of which we will not talk about
now. You can quickly take a peek into the information and functions stored in
the `SP` object. The following code gives a lot of output and we suggest you
return back to this point once you are comfortable with the basic functionality!

```{r SP, eval = FALSE}
show(SP)
```

From the simulated genomes, we will create virgin queens. These will serve as
our our first honeybee individuals. In SIMplyBee, we use AlphaSimR's populations
(`Pop` class). So, the `basePop` is a population of two individuals, our virgin
queens.

```{r base pop virgin queens}
baseQueens <- createVirginQueens(founderGenomes)
baseQueens
isVirginQueen(baseQueens)
```

We will use the first virgin queen to create five drones for mating.
Technically, virgin queens do not create drones. Only queens with colonies
create drones. However, to get the simulation up and running, we need drones and
the function `createDrones()` can work both with virgin queens or colonies (we
will talk about colonies in the next section).

```{r base pop drones}
baseDrones <- createDrones(x = baseQueens[1], nInd = 15)
baseDrones
```

A keen reader will notice that drones' ploidy is two. We will address this in
the next sections.

# Creating and building up a colony

We will use the other virgin queen to create a colony. In SIMplyBee, a colony is
an object of `Colony` class with all sorts of information.

```{r colony}
colony <- createColony(x = baseQueens[2])
colony
```

Before we look into the colony, lets mate the virgin queen, so that she becomes
a queen and can start laying eggs for her own workers and drones.

```{r cross colony}
colony <- cross(colony, drones = baseDrones)
colony
```

We build up colony with workers and drones using `buildUpColony()`.

```{r build up colony}
buildUp(colony, nWorkers = 10, nDrones = 7)
```

Of note, we have not saved the result of the `buildUpColony()` call, so our
currently saved colony object `colony` still doesn't contain workers and drones.

At this point, its worth mentioning that `SimParamBee` (saved as the `SP`
object) conveniently holds some defaults for the number of workers and drones.
The defaults are just some numbers to work with. You should adapt these defaults
to your needs.

```{r SP n values}
SP$nWorkers
```

```{r SP n values 2}
SP$nDrones
```

When we run SIMplyBee functions, such defaults are automatically used. We show
this now by calling the `buildUp()` function on our colony. Note that now we are
saving the function output and rewriting the currently saved colony object.

```{r build up colony with defaults}
colony <- buildUp(colony)
colony
```

# Colony structure

Lets explore this colony. In every colony we have different groups of
individuals (castes). These include: queen, fathers, workers, drones, and virgin
queens. The queen controls the colony, workers do all the hard work, drones
disseminate queen's genes, and one of the virgin queens will eventually replace
the queen. We also store fathers, which represent drones that the queen mated
with. Storing fathers enables us to generate colony members on demand. Let's
count how many individuals we have for each caste.

```{r colony numbers 1}
nQueens(colony)
```

```{r colony numbers 2}
nFathers(colony)
```

```{r colony numbers 3}
nWorkers(colony)
```

```{r colony numbers 4}
nDrones(colony)
```

```{r colony numbers 5}
nVirginQueens(colony)
```

We can also access castes using `get*()` functions.

```{r colony castes via get 1}
(queen <- getQueen(colony))
```

```{r colony castes via get 2}
(fathers <- getFathers(colony))
```

```{r colony castes via get 3}
(workers <- getWorkers(colony))
```

```{r colony castes via get 4}
(drones <- getDrones(colony))
```

```{r colony castes via get 5}
(virginQueens <- getVirginQueens(colony))
```

As you see above, there are no virgin queens present in the colony at this
moment, since the queen is active. Future colony events will change this.

Should you want to pull out, that is, remove castes, or their members, have a
look at `pull*()` functions.

There is additional information that you can retrieve. Peek under the hood and
view the complete colony data structure with `str(colony)`. This gives a lot of
output and we suggest you return back to this point once you are comfortable
with the basic functionality!

```{r colony structure, eval = FALSE}
str(colony)
```

To explore the various accessor or modification functions, study the SIMplyBee's
index of functions.

TODO: point to PkdDown too

```{r help, eval = FALSE}
help(SIMplyBee)
```

The caste information of colony members is as you would expect:

```{r caste queen}
getCaste(queen)
```

```{r caste fathers}
getCaste(fathers)
```

and so on. When you have a bunch of bees at hand and you might not know their
source, the `getCaste()` can be very useful.

```{r caste bees}
bees <- c(queen, fathers[1:2], workers[1:2], drones[1:2])
getCaste(bees)
```

# Complementary sex determining locus

TODO: add genome image (tree and inheritance and csd)?

The complementary sex determining (csd) locus, well, complements sex
determination. Fertilised eggs that are heterozygous at the csd locus develop
into workers. On the other hand, homozygous eggs develop into unviable drones.
These drones are usually discarded by workers. SIMplyBee doesn't store these
unviable drones, but it does store their number.

We can retrieve information about csd variation with `getCsdAlleles()`. For
details on where the csd locus is and the number of distinct alleles, see
`help(SimParamBee)`. The output below shows two sequences (in two rows) of 0s
and 1s representing respectively ancestral and mutation alleles along the csd
locus for the queen. You can see that the two sequences are different, meaning
that she is heterozygous, as expected.

```{r csd}
getCsdAlleles(queen)
```

Technically, SIMplyBee represents the csd locus as a series of bi-allelic single
nucleotide polymorphisms that don't recombine. So, the csd locus is represented
as a haplotype and different haplotypes represent different csd alleles. By
varying the number of sites within the csd locus we can control the number of
distinct alleles (see `help(SimParamBee)`).

A keen geneticist would immediately inspect csd alleles of fathers to check for
any similarity with the queen's csd alleles. Lets boost a chance of such an
event by creating an inbreed colony. We will create a virgin queen from the
current colony and mate her with her brothers. Oh, dear me.

```{r inbred colony}
inbredColony <- createColony(x = createVirginQueens(x = colony, nInd = 1))
fathers <- selectInd(drones, nInd = SP$nFathers, use = "rand")
inbredColony <- cross(inbredColony, drones = fathers)
getCsdAlleles(inbredColony)
getCsdAlleles(inbredColony, unique = TRUE)
```

Can you spot any matches? Let's calculate the expected proportion of homozygous
brood from this mating.

```{r pHomBrood}
pHomBrood(inbredColony)
```

Let's see how many homozygotes will we observe. Note that inheritance is a
random process, so a realised number of homozygotes will deviate from the
expected proportion.

```{r hHomBrood}
inbredColony <- addWorkers(inbredColony, nInd = 100)
inbredColony
nHomBrood(inbredColony)
```

We tried adding 100 workers, but we only got `r nWorkers(inbredColony)`. The
difference of `r nHomBrood(inbredColony)` is due to csd homozygous brood. Let's
add another set of workers to show variation in realised numbers and
accumulation of information.

```{r hHomBrood II}
inbredColony <- addWorkers(inbredColony, nInd = 100)
inbredColony
nHomBrood(inbredColony)
```

In total we tried adding 200 workers. We got `r nWorkers(inbredColony)` workers
and `r nHomBrood(inbredColony)` homozygous brood. To see all this information,
we can inspect the miscellaneous slot of the queen that contains the fathers
population as well as the cumulative number of workers, drones, homozygous
brood, and the expected proportion of homozygous brood.

```{r queens counters}
getMisc(getQueen(inbredColony))
```

# Inheritance system

TODO: add genome image (tree and inheritance and csd)? TODO: mention
recombination - why (I can't recall anymore)?

Honeybees have the haplo-diploid inheritance system where queens and workers are
diploid and drones are haploid. In SIMplyBee, we simulate drones as
doubled-haploids, that is, as fully homozygous diploid individuals. This means
that they have two identical sets of chromosomes. When they produce sperm, their
gametes all have the same one set of chromosomes. Despite them being diploid, we
generally return a haploid set of chromosomes, unless specifically requested.

To show all this, let's get haplotypes and genotypes across the segregating
sites for the different castes. The haplotypes are below shown in rows, spanning
sites in columns (limiting to the first ten sites). Genotypes are simply a sum
of the two haplotypes. First the queen:

```{r queens haplo}
getQueenSegSiteHaplo(inbredColony)[, 1:10]
```

```{r queens geno}
getQueenSegSiteGeno(inbredColony)[, 1:10]
```

now all fathers:

```{r fathers haplo}
getFathersSegSiteHaplo(inbredColony)[, 1:10]
```

```{r fathers geno}
getFathersSegSiteGeno(inbredColony)[, 1:10]
```

each father is listed once (one row per father), but we can retrieve the diploid
state, if this is desired (showing just one father to show this clearly):

```{r fathers haplo 2}
getFathersSegSiteHaplo(inbredColony, nInd = 1, dronesHaploid = FALSE)[, 1:10]
```

```{r fathers geno 2}
getFathersSegSiteGeno(inbredColony, nInd = 1, dronesHaploid = FALSE)[, 1:10, drop = FALSE]
```

now two workers:

```{r workers haplo}
getWorkersSegSiteHaplo(inbredColony, nInd = 2)[, 1:10]
```

```{r workers geno}
getWorkersSegSiteGeno(inbredColony, nInd = 2)[, 1:10]
```

and finally four drones:

```{r drones haplo}
inbredColony <- addDrones(inbredColony, nInd = 4)
getDronesSegSiteHaplo(inbredColony)[, 1:10]
```

```{r drones geno}
getDronesSegSiteGeno(inbredColony)[, 1:10]
```

SIMplyBee has the same genome retrieval functions as AlphaSimR, for all
segregating sites (`segSite`), quantitative trait loci (`qtl`), identity by
descent (`ibd`), and marker array/chip (`chip`). Here, site, locus and marker
are all synonyms for a position in the genome. Study the index of available
`get*()` functions in SIMplyBee and read the genomics vignette for more
information.

```{r help II}
help(SIMplyBee)
```
