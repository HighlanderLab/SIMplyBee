# Level 3 Colonies Functions

#' @rdname createColonies
#' @title Create colonies
#'
#' @description Creates a set of colonies
#'
#' @param ... one or more \code{\link{Colony-class}}, \code{\link{Colonies-class}},
#' or \code{NULL} objects
#' @param n numeric, number of colonies to create; this argument takes precedence
#' over \code{...}
#'
#' @return A \code{\link{Colonies-class}} object
#'
#' @examples
#' # Create 10 empty (NULL) colonies
#' apiary <- createColonies(n = 10)
#' apiary
#' apiary[[1]]
#' apiary[[2]]
#'
#' # Create an apiary from two existing colonies
#' founderGenomes <- quickHaplo(nInd = 3, nChr = 1, segSites = 100)
#' SP <- SimParamBee$new(founderGenomes)
#' basePop <- newPop(founderGenomes)
#'
#' drones <- createFounderDrones(pop = basePop[2], nDronesPerQueen = 10)
#' colony1 <- createColony(queen = basePop[1], fathers = drones)
#' colony2 <- createColony(virgin_queens = basePop[3])
#' apiary <- createColonies(colony1, colony2)
#' apiary
#' apiary[[1]]
#' apiary[[2]]
#'
#' # ... an alternative
#' apiary <- c(colony1, colony2)
#' apiary
#' apiary[[1]]
#' apiary[[2]]
#'
#' @export
createColonies <- function(..., n = NULL) {
  if (is.null(n)) {
    input <- list(...)
    class <- ifelse(length(input) == 0, "NULL", sapply(input, "class"))
    if (!all("NULL" %in% class | "Colony" %in% class | "Colonies" %in% class)) {
      stop("Arguments have to be a NULL, Colony, or Colonies class object!")
    }
    output <- new("Colonies", colonies = input)
  } else {
    output <- new("Colonies", colonies = vector(mode = "list", length = n))
  }
  return(output)
}

#' @rdname createColonies2
#' @title Create colonies (a version that will encompass createColonies soon) TODO
#'
#' @description Create a set of colonies. Usually at a start simulation.
#'
#' @param pop \code{\link{Pop-class}}, individuals that will be used to seed
#'   queens and drones in colonies (these individuals are selected at random if
#'   there are more than \code{n})
#' @param n integer, number of colonies to create (if only \code{n} is given
#'   then empty (\code{NULL}) colonies are created - mostly useful for
#'   programming)
#' @param mated logical, create mated or unmated (virgin) colonies
#' @param nAvgFathers integer, number of drones that a queen mates with
#'   TODO nAvgFathers default should go to simParamBee and then we set it to NULL
#'        here and if its NULL we grab value from simParamBee, otherwise use it
#'        from the user
#' @param nDronesPerQueen integer, number of drones that a queen generates
#'   TODO nDronesPerQueen default should go to simParamBee and then we set it to NULL
#'        here and if its NULL we grab value from simParamBee, otherwise use it
#'        from the user
#' @param simParamBee \code{\link{SimParamBee}}, global simulation parameters
#'
#' @return \code{\link{Colonies-class}}
#'
#' @examples
#' founderGenomes <- quickHaplo(nInd = 3, nChr = 1, segSites = 100)
#' SP <- SimParamBee$new(founderGenomes)
#' basePop <- newPop(founderGenomes)
#'
#' # Create 2 empty (NULL) colonies
#' apiary <- createColonies2(n = 2)
#' apiary
#' apiary[[1]]
#' apiary[[2]]
#'
#' # Create 2 mated colonies
#' apiary <- createColonies2(pop = basePop, n = 2)
#' apiary
#' apiary[[1]]
#' apiary[[2]]
#'
#' # Create 2 unmated/virgin colonies
#' apiary <- createColonies2(pop = basePop, n = 2, mated = FALSE)
#' apiary
#' apiary[[1]]
#' apiary[[2]]
#'
#' @export
createColonies2 <- function(pop = NULL, n, mated = TRUE,
                            nAvgFathers = 15, nDronesPerQueen = 100, simParamBee = NULL) {
  if (is.null(simParamBee)) {
    simParamBee <- get(x = "SP", envir = .GlobalEnv)
  }
  if (!is.null(pop)) {
    if (!isPop(pop)) {
      stop("Argument pop must be a Pop class object!")
    }
    ret <- new("Colonies", colonies = vector(mode = "list", length = n))
    if (mated) {
      tmp <- pullInd(pop = pop, nInd = n)
      queens <- tmp$pulled
      DCA <- createFounderDrones(pop = tmp$remainder, nDronesPerQueen = nDronesPerQueen)
      fatherPackages <- pullDroneGroupsFromDCA(DCA, nGroup = n, avgGroupSize = nAvgFathers)
      for (colony in 1:n) {
        ret@colonies[[colony]] <- createColony(queen = queens[colony],
                                               fathers = fatherPackages[[colony]],
                                               simParamBee = simParamBee)
      }
    } else {
      virginQueens <- selectInd(pop, nInd = n, use = "rand")
      for (colony in 1:n) {
        ret@colonies[[colony]] <- createColony(virgin_queens = virginQueens[colony],
                                               simParamBee = simParamBee)
      }
    }
  } else if (!is.null(n)) {
    ret <- new("Colonies", colonies = vector(mode = "list", length = n))
  } else {
    stop("You must provide either pop and n or at least n!")
  }
  return(ret)
}

#' @rdname addColonyToColonies
#' @title Add a colony to colonies
#'
#' @description Adds a colony to a set of colonies, for example, to add a new
#' colony to an apiary.
#'
#' @param colonies \code{\link{Colonies-class}}, colonies that will be expanded
#' @param colony \code{\link{Colony-class}}, colony that will be added
#'
#' @return Expanded \code{\link{Colonies-class}} object
#'
#' @examples
#' founderGenomes <- quickHaplo(nInd = 6, nChr = 1, segSites = 100)
#' SP <- SimParamBee$new(founderGenomes)
#' basePop <- newPop(founderGenomes)
#'
#' founderDrones <- createFounderDrones(pop = basePop[1:3], nDronesPerQueen = 10)
#' colony1 <- createColony(queen = basePop[4], fathers = founderDrones[1:10])
#' colony2 <- createColony(queen = basePop[5], fathers = founderDrones[11:20])
#' colony3 <- createColony(queen = basePop[6], fathers = founderDrones[21:30])
#' apiary <- c(colony1, colony2)
#'
#' # Add colony to the apiary
#' apiaryNew <- addColonyToColonies(apiary, colony3)
#' getId(apiary)
#' getId(apiaryNew)
#' # ... an alternative
#' apiaryNew <- c(apiary, colony3)
#' getId(apiaryNew)
#'
#' @export
addColonyToColonies <- function(colonies, colony) {
  if (!isColony(colonies)) {
    stop("Argument Colonies must be a Colonies class object!")
  }
  if (!isColony(colony)) {
    stop("Argument colony must be a Colony class object!")
  }
  colonies@colonies <- c(colonies@colonies, colony)
  return(colonies)
}

#' @rdname assignColonyToColonies
#' @title Assign (replace) a colony to colonies
#'
#' @description Assigns (replaces) a colony among a set of colonies, for example,
#' to replace an old colony. By defining a position, it will insert the colony to
#' that position and with this replace the old colony at that position.
#'
#' @param colony Colony, colony that will be added
#' @param colonies Colonies, set of colonies that will be expanded
#' @param pos numeric or character, position of the old colony
#'
#' @return Expanded \code{\link{Colonies-class}} object
#'
#' @examples
#' founderGenomes <- quickHaplo(nInd = 6, nChr = 1, segSites = 100)
#' SP <- SimParamBee$new(founderGenomes)
#' basePop <- newPop(founderGenomes)
#'
#' founderDrones <- createFounderDrones(pop = basePop[1:3], nDronesPerQueen = 10)
#' colony1 <- createColony(queen = basePop[4], fathers = founderDrones[1:10])
#' colony2 <- createColony(queen = basePop[5], fathers = founderDrones[11:20])
#' colony3 <- createColony(queen = basePop[6], fathers = founderDrones[21:30])
#' apiary <- c(colony1, colony2)
#'
#' getId(apiary)
#' apiary <- assignColonyToColonies(apiary, colony3, pos = 2)
#' getId(apiary)
#'
#' @return Expanded Colonies object
#'
#' @export
assignColonyToColonies <- function(colonies, colony, pos) {
  if (!isColony(colonies)) {
    stop("Argument Colonies must be a Colonies class object!")
  }
  if (!isColony(colony)) {
    stop("Argument colony must be a Colony class object!")
  }
  colonies@colonies[[pos]] <- colony
  return(colonies)
}

#' @rdname selectColonies
#' @title Select individual colonies from a set of colonies
#'
#' @description Select individual colonies from a set of colonies based on colony
#' index or name
#'
#' @param colonies Colonies, a set of colonies
#' @param ID numeric or character, name of a colony (one or more) in
#' \code{colonies}; note that numeric value is effectively converted to character
#' - see examples how to select by index
#'
#' @examples
#' founderGenomes <- quickHaplo(nInd = 6, nChr = 1, segSites = 100)
#' SP <- SimParamBee$new(founderGenomes)
#' basePop <- newPop(founderGenomes)
#'
#' founderDrones <- createFounderDrones(pop = basePop[1:3], nDronesPerQueen = 10)
#' colony1 <- createColony(queen = basePop[4], fathers = founderDrones[1:10])
#' colony2 <- createColony(queen = basePop[5], fathers = founderDrones[11:20])
#' colony3 <- createColony(queen = basePop[6], fathers = founderDrones[21:30])
#' apiary <- c(colony1, colony2, colony3)
#'
#' selectColonies(apiary, ID = 4)
#' selectColonies(apiary, ID = "4")
#' selectColonies(apiary, ID = c(4, 5))
#' selectColonies(apiary, ID = c("4", "5"))
#'
#' apiary[1]
#' apiary[[1]]
#' apiary["4"]
#' apiary[["4"]]
#' getId(apiary[c(1, 2)])
#' getId(apiary[c("4", "5")])
#' getId(apiary[c(2, 1)])
#' getId(apiary[c("5", "4")])
#'
#' @return Colonies
#'
#' @export
selectColonies <- function(colonies, ID = NULL, p = NULL) {
  if (!isColonies(colonies)) {
    stop("Argument colonies must be a Colonies class object!")
  }
  if (!is.null(ID)) {
    ret <- colonies[getId(colonies) %in% ID]
  } else if (!is.null(p)) {
    lPull <- as.logical(rbinom(n = nColonies(colonies), size = 2, p = p))
    if (any(lPull)) {
      ret <- colonies[lPull]
    } else {
      ret <- NULL
    }
  } else {
    stop("Provide either ID or p!")
  }
  return(ret)
}

#' @rdname pullColonies
#' @title Pull some colonies from a larger set of colonies
#'
#' @description Pull the colonies from the list of all colonies based on colony
#' IDs and return two lists: a list of selected colonies and updated original
#' colonies.
#'
#' @param colonies Colonies, a set of colonies
#' @param ID numeric or character, name of a colony (one or more) in
#' \code{colonies}; note that numeric value is effectively converted to character
#' @param p numeric, probability of a colony being pulled
#'
#' @examples
#' founderGenomes <- quickHaplo(nInd = 4, nChr = 1, segSites = 100)
#' SP <- SimParamBee$new(founderGenomes)
#' basePop <- newPop(founderGenomes)
#'
#' apiary <- createColonies2(pop = basePop, n = 3)
#' (names <- getId(apiary))
#'
#' tmp <- pullColonies(apiary, ID = names[1])
#' getId(tmp$pulledColonies)
#' getId(tmp$remainingColonies)
#'
#' tmp <- pullColonies(apiary, p = 0.5)
#' getId(tmp$pulledColonies)
#' getId(tmp$remainingColonies)
#'
#' @return Colonies
#'
#' @export
pullColonies <- function(colonies, ID = NULL, p = NULL) {
  if (!isColonies(colonies)) {
    stop("Argument colonies must be a Colonies class object!")
  }
  if (!is.null(ID)) {
    pulledColonies <- selectColonies(colonies, ID)
    remainingColonies <- removeColonies(colonies, ID)
  } else if (!is.null(p)) {
    lPull <- as.logical(rbinom(n = nColonies(colonies), size = 2, p = p))
    message(paste0("Pulling out ", sum(lPull), " colonies."))
    if (any(lPull)) {
      ids <- getId(colonies)
      pulledColonies <- selectColonies(colonies, ids[lPull])
      remainingColonies <- removeColonies(colonies, ids[lPull])
    } else {
      pulledColonies <- createColonies()
      remainingColonies <- colonies
    }
  } else {
    stop("You must provide either ID or p!")
  }
  ret <- list(pulledColonies = pulledColonies, remainingColonies = remainingColonies)
  return(ret)
}

#' @rdname removeColonies
#' @title Remove the colonies from the colony list based on IDs
#'
#' @description Remove the colonies from the list of all colonies based
#' on colony IDs and return a list of remaining colonies.
#'
#' @param colonies Colonies
#' @param ID character, IDs of colony(ies) in \code{colonies}
#'
#' @examples
#' founderGenomes <- quickHaplo(nInd = 4, nChr = 1, segSites = 100)
#' SP <- SimParamBee$new(founderGenomes)
#' basePop <- newPop(founderGenomes)
#'
#' apiary <- createColonies2(pop = basePop, n = 3)
#' (names <- getId(apiary))
#'
#' getId(removeColonies(apiary, ID = names[1]))
#' getId(removeColonies(apiary, ID = names[c(2, 3)]))
#'
#' @return Colonies
#'
#' @export
removeColonies <- function(colonies, ID) {
  if (!isColonies(colonies)) {
    stop("Argument colonies must be a Colonies class object!")
  }
  ret <- colonies[!getId(colonies) %in% ID]
  return(ret)
}

#' @rdname createColoniesFromAPop
#' @title  A merger of the createVirginColonies and createMatedColonies
#' @description Virgin Colonies description:  This function is intended for quickly creating multiple mated or unmated/virgin
#' colonies, often at the start of a simulation - to seed the simulation. To create virgin colonies this
#' function takes a population, pulls out virgin queens to initiate the colonies. To create mated colonies
#' this function takes a population, pulls out queens, creates drones from the remainder, and then
#' mates the queens to initiate the colonies. Other caste members have to be added later!
#'
#' @param pop TODO
#' @param nColonies TODO
#' @param nAvgFathers TODO
#' @param nDronesPerQueen TODO
#'
#' @examples
#' founderGenomes <- quickHaplo(nInd = 4, nChr = 1, segSites = 100)
#' SP <- SimParamBee$new(founderGenomes)
#' basePop <- newPop(founderGenomes)
#'
#' apiary <- createVirginColonies(pop = basePop, nColonies = 3)
#' nQueens(apiary)
#' nVirginQueens(apiary)
#' nFathers(apiary)
#' nWorkers(apiary)
#' nDrones(apiary)
#'
#' @return Colonies
#'
#' @export
createColoniesFromAPop <- function(pop, nColonies, nAvgFathers = NULL,
                                   nDronesPerQueen = 100, simParamBee = NULL) {
  if (is.null(simParamBee)) {
    simParamBee <- get(x = "SP", envir = .GlobalEnv)
  }
  if (!isPop(pop)) {
    stop("Argument pop must be a Pop class object!")
  }
  ret <- createColonies(n = nColonies)
  if (is.null(nAvgFathers)) {
    virginQueens <- selectInd(pop, nInd = nColonies, use = "rand")
    for (colony in 1:nColonies) {
      ret@colonies[[colony]] <- createColony(virgin_queens = virginQueens[colony],
                                             simParamBee = simParamBee)
    }
  } else {
    tmp <- pullInd(pop = pop, nInd = nColonies)
    queens <- tmp$pulled
    DCA <- createFounderDrones(pop = tmp$remainder, nDronesPerQueen = nDronesPerQueen)
    fatherPackages <- pullDroneGroupsFromDCA(DCA, nGroup = nColonies, avgGroupSize = nAvgFathers)
    for (colony in 1:nColonies) {
      ret@colonies[[colony]] <- createColony(queen = queens[colony],
                                             fathers = fatherPackages[[colony]],
                                             simParamBee = simParamBee)
    }
  }
  return(ret)
}

#' @rdname buildUpColonies
#' @title  Build up Colonies by adding workers and drones
#'
#' @description Workers and drones are added to the colonies to build them
#' up to the number of desired workers and drones (nWorkers and nDrones).
#' For example: a user may build up colonies in the Period 1 and if events such as split or swarming
#' occur.
#'
#' @param colonies AlphaSimRBee Colonies object containing a list of colonies
#' @param nWorkers Desired number of workers wanted in the colonies
#' @param nDrones Desired number of drones wanted in the colonies
#'
#' @examples
#' #Create founder haplotypes
#' founderGenomes <- quickHaplo(nInd=200, nChr=1, segSites=100)
#'
#' #Set simulation parameters
#' SP <- SimParamBee$new(founderGenomes)
#'
#' #Create population
#' base <- newPop(founderGenomes)
#'
#' #Create 10 virgin queen colonies
#'  apiary1 <- createMultipleMatedColonies(founderPop = base, nColonies = 10, nAvgFathers = 15)
#'
#' #Build up colonies by adding 1000 workers and 100 drones to each colony in the "colonies" list
#'  apiary1 <- buildUpColonies(apiary1, nWorkers = 1000)
#'
#' @return An updated AlphaSimRBee Colonies object
#'
#' @export
buildUpColonies <- function(colonies, nWorkers, nDrones = nWorkers * 0.1,
                            new = FALSE, simParamBee = NULL) {
  if (is.null(simParamBee)) {
    simParamBee <- get(x = "SP", envir = .GlobalEnv)
  }
  nCol <- nColonies(colonies)
  for (colony in 1:nCol) {
    colonies@colonies[[colony]] <- buildUpColony(colony = colonies[[colony]],
                                                 nWorkers = nWorkers,
                                                 nDrones = nDrones,
                                                 new = new,
                                                 simParamBee = simParamBee)
  }
  return(colonies)
}

#' @rdname replaceWorkersColonies
#' @title  Replace workers in all the colonies of a Colonies object
#'
#' @description The function replaces a given proportion of workers in all the colonies
#' of a Colonies object with new workers from the same mated queen. The default percentage
#' is set to 1, hence replacing all workers If some colonies do not have workers, the
#' function does not add them.
#'
#' @param colonies AlphaSimRBee Colonies object containing a list of colonies
#'
#' @examples
#' #Create founder haplotypes
#' founderGenomes <- quickHaplo(nInd=200, nChr=1, segSites=100)
#'
#' #Set simulation parameters
#' SP <- SimParamBee$new(founderGenomes)
#'
#' #Create population
#' base <- newPop(founderGenomes)
#'
#' #Create 10 virgin queen colonies
#'  apiary1 <- createMultipleMatedColonies(founderPop = base, nColonies = 10, nAvgFathers = 15)
#'
#' #Build up colonies by adding 1000 workers and 100 drones to each colony in the "colonies" list
#'  apiary1 <- buildUpColonies(apiary1, nWorkers = 1000)
#'
#' #Replace the workers
#'   apiary1 <- replaceWorkers(apiary1)
#'
#' @return An updated AlphaSimRBee Colonies object
#'
#' @export
replaceWorkersColonies <- function(colonies, p = 1, simParamBee = NULL) {
  if (is.null(simParamBee)) {
    simParamBee <- get(x = "SP", envir = .GlobalEnv)
  }
  nCol <- nColonies(colonies)
  for (colony in 1:nCol) {
    if (!is.null(colonies[[colony]]@workers)) {
      colonies@colonies[[colony]] <- replaceWorkers(colony = colonies[[colony]],
                                                    p = p,
                                                    simParamBee = simParamBee)
    }
  }
  return(colonies)
}

#' @rdname replaceDronesColonies
#' @title  Replace drones in all the colonies of a Colonies object
#'
#' @description The function replaces a given proportion of drones in all the colonies
#' of a Colonies object with new drones from the same queen. The default percentage
#' is set to 1, hence replacing all drones. If some colonies do not have drones, the
#' function does not add them.
#'
#' @param colonies AlphaSimRBee Colonies object containing a list of colonies
#'
#' @examples
#' #Create founder haplotypes
#' founderGenomes <- quickHaplo(nInd=200, nChr=1, segSites=100)
#'
#' #Set simulation parameters
#' SP <- SimParamBee$new(founderGenomes)
#'
#' #Create population
#' base <- newPop(founderGenomes)
#'
#' #Create 10 virgin queen colonies
#'  apiary1 <- createMultipleMatedColonies(founderPop = base, nColonies = 10, nAvgFathers = 15)
#'
#' #Build up colonies by adding 1000 workers and 100 drones to each colony in the "colonies" list
#'  apiary1 <- buildUpColonies(apiary1, nWorkers = 1000)
#'
#' #Replace the drones
#'   apiary1 <- replaceDrones(apiary1)
#'
#' @return An updated AlphaSimRBee Colonies object
#'
#' @export
replaceDronesColonies <- function(colonies, p = 1) {
  nCol <- nColonies(colonies)
  for (colony in 1:nCol) {
    if (!is.null(colonies[[colony]]@drones)) {
      colonies@colonies[[colony]] <- replaceDrones(colony = colonies[[colony]],
                                                   p = p)
    }
  }
  return(colonies)
}

#' @rdname reQueenColonies
#' @title TODO
#'
#' @description: Add a new queen/virgin queen into the queens slot of the colonies.
#' For example: this can be used to re-queen swarmed or split colonies where no queens are present.
#'
#' @param colonies AlphaSimRBee Colonies object containing a list of colonies
#' @param queens Selected individuals to insert into the queen slot of the colony object
#'
#' @examples
#' #Create founder haplotypes
#' founderGenomes <- quickHaplo(nInd=200, nChr=1)
#'
#' #Set simulation parameters
#' SP <- SimParamBee$new(founderGenomes)
#'
#' #Create population
#' base <- newPop(founderGenomes)
#'
#' #Create 10 virgin queen colonies
#'  apiary1 <- createMultipleMatedColonies(founderPop = base, nColonies = 10, nAvgFathers = 15)
#'
#' #Build up colonies by adding 1000 workers and 100 drones to each colony in the "colonies" list
#'  apiary1 <- buildUpColonies(apiary1, nWorkers = 1000)
#'
#'  #Split all the colonies
#'  tmp <- splitColonies(apiary1)
#'  apiary1 <- tmp$remnants
#'  splitcolonies <- tmp$splits
#'
#'  #Create 10 virgin queens
#'  virginQueens <- createVirginQueens(apiary1[[10]], nColonies(splitcolonies))
#'
#'  # Requeen the splits
#'  splitcolonies <- reQueenColonies(splitcolonies, queens = virginQueens)
#'
#' @return An updated AlphaSimRBee Colonies object
#'
#' @export
reQueenColonies <- function(colonies, queens) {
  nCol <- nColonies(colonies)
  if (nInd(queens) < nCol) {
    stop("Not enough queens!")
  }
  for (colony in 1:nCol) {
    colonies@colonies[[colony]] <- reQueenColony(colony = colonies[[colony]],
                                                 queen = queens[colony])
  }
  return(colonies)
}

#' @rdname crossColonies
#' @title TODO
#'
#' @description:  Crosses colonies with a virgin queen to a group of fathers pulled from the DCA
#' \creates workers, drones and a new virgin queen and write them to the corresponding
#' \slots of the colonies object.
#' #IF the colonies are queen-less - select a queen from the virgin queen - if not, mate the current queen!!!
#'
#' @param colonies AlphaSimRBee Colonies object containing a list of colonies
#' @param crossVirginQueen  TODO
#' @param fathers TODO
#' @param pWorkers TODO
#' @param pDrones TODO
#' @param DCA TODO
#' @param nAvgFathers TODO
#'
#' @examples
#' #Create founder haplotypes
#' founderGenomes <- quickHaplo(nInd = 200, nChr = 1, segSites = 100)
#'
#' #Set simulation parameters
#' SP <- SimParamBee$new(founderGenomes)
#'
#' #Create population
#' base <- newPop(founderGenomes)
#'
#' #Create 10 virgin queen colonies
#'  apiary1 <- createMultipleMatedColonies(founderPop = base, nColonies = 10, nAvgFathers = 15)
#'
#' #Build up colonies by adding 1000 workers and 100 drones to each colony in the "colonies" list
#'  apiary1 <- buildUpColonies(apiary1, nWorkers = 1000)
#'
#'  TODO FINISH
#'
#' @return An updated AlphaSimRBee Colonies object
#'
#' @export
crossColonies <- function(colonies, DCA, nAvgFathers, simParamBee = NULL) {
  if (is.null(simParamBee)) {
    simParamBee <- get(x = "SP", envir = .GlobalEnv)
  }
  nCol <- nColonies(colonies)
  if (nCol == 0) {
    ret <- createColonies()
  } else {
    ret <- createColonies(n = nCol)
    nFathers <- rpois(n = nCol, lambda = nAvgFathers)
    fatherGroups <- pullDroneGroupsFromDCA(DCA, nGroup = nCol,
                                           avgGroupSize = nAvgFathers)
    for (colony in 1:nCol) {
      ret@colonies[[colony]] <- crossColony(colonies[[colony]],
                                            fathers = fatherGroups[[colony]],
                                            simParamBee = simParamBee)
    }
  }
  return(ret)
}

#' @rdname collapseColonies
#' @title TODO
#'
#' @description TODO
#'
#' @param colonies AlphaSimRBee Colonies object containing a list of colonies
#' @param ID IDs of "colony" class objects listed in the "colonies" object
#'
#' @examples
#'# Create founder haplotypes
#'
#' founderGenomes <- quickHaplo(nInd=300, nChr=1, segSites=100)
#'
#' # Set simulation parameters
#'
#' SP <- SimParamBee$new(founderGenomes)
#'
#' # Create population
#'
#' pop <- newPop(founderGenomes)
#'
#' # Create colonies
#'
#' founderDrones <- createFounderDrones(pop[13:300], nDronesPerQueen = 17)
#' colony1 <- createColony(queen = pop[1], fathers = founderDrones[1:17])
#' colony2 <- createColony(queen = pop[2], fathers = founderDrones[18:37])
#' colony3 <- createColony(queen = pop[3], fathers = founderDrones[37:51])
#'
#' # Put the colonies together to the apiary
#'
#' apiary <- c(colony1, colony2, colony3)
#'
#' # Collapse colonies
#'
#' apiary <- collapseColonies(apiary, ID = c(1,2))
#'
#' @return An updated AlphaSimRBee Colonies object
#'
#' @export
collapseColonies <- function(colonies, ID) {
  ret <- removeColonies(colonies, ID)
  return(ret)
}

#' @rdname swarmColonies
#' @title TODO
#'
#' @description: Replicates the swarming of the colonies - the process in which
#' a part of the workers leave with the old queen and creates a new colony (the swarm),
#' while a part of the workers stay with a new queen and the old drones.
#' The swarming colony contains the old mated queen, a percentage (pSwarm)
#' of the original colony's workers, no drones and a virgin queen is created from the worker population.
#' A new location must be given to the new swarm colony.
#' The colony that stays contains the remaining workers and drones.
#' A virgin queen is selected from the workers and mated if fathers are present.
#'
#' @param colonies AlphaSimRBee Colonies object containing a list of colonies
#' @param crossVirginQueen TODO
#' @param fathers TODO
#' @param pWorkers TODO
#' @param pDrones TODO
#'
#' @examples
#' #Create founder haplotypes
#' founderGenomes <- quickHaplo(nInd=200, nChr=1, segSites=100)
#'
#' #Set simulation parameters
#' SP <- SimParamBee$new(founderGenomes)
#'
#' #Create population
#' base <- newPop(founderGenomes)
#'
#' #Create 10 virgin queen colonies
#'  apiary1 <- createMultipleMatedColonies(founderPop = base, nColonies = 10, nAvgFathers = 15)
#'
#' #Build up colonies by adding 1000 workers and 100 drones to each colony in the "colonies" list
#'  apiary1 <- buildUpColonies(apiary1, nWorkers = 1000)
#'
#' @return Two AlphaSim population objects of the swarmed colonies and the remaining colonies
#'
#' @export
swarmColonies <- function(colonies, simParamBee = NULL) {
  if (is.null(simParamBee)) {
    simParamBee <- get(x = "SP", envir = .GlobalEnv)
  }
  nCol <- nColonies(colonies)
  if (nCol == 0) {
    ret <- list(swarms = createColonies(n = 0),
                remnants = createColonies(n = 0))
  } else {
    ret <- list(swarms = createColonies(n = nCol),
                remnants = createColonies(n = nCol))
    for (colony in 1:nCol) {
      tmp <- swarmColony(colonies[[colony]], simParamBee = simParamBee)
      ret$swarms@colonies[[colony]] <- tmp$swarm
      ret$remnants@colonies[[colony]] <- tmp$remnant
    }
  }
  return(ret)
}

#' @rdname supersedeColonies
#' @title Supersede colony for all given colonies
#'
#' @description The same as \code{\link{supersedeColony}} but for all given
#'   colonies.
#'
#' @param colonies \code{\link{Colonies-class}}
#'
#' @return \code{\link{Colonies-class}}
#'
#' @examples
#' founderGenomes <- quickHaplo(nInd = 3, nChr = 1, segSites = 100)
#' SP <- SimParamBee$new(founderGenomes)
#' basePop <- newPop(founderGenomes)
#'
#' drones <- createFounderDrones(pop = basePop[1], nDronesPerQueen = 10)
#' colony1 <- createColony(queen = basePop[2], fathers = drones[1:5])
#' (colony1 <- buildUpColony(colony1, nWorkers = 100))
#' colony2 <- createColony(queen = basePop[3], fathers = drones[6:10])
#' (colony2 <- buildUpColony(colony2, nWorkers = 100))
#' apiary <- c(colony1, colony2)
#' apiary
#' apiary[[1]]
#' apiary[[2]]
#'
#' apiary <- supersedeColonies(apiary)
#' apiary
#' apiary[[1]]
#' apiary[[2]]
#'
#' @export
supersedeColonies <- function(colonies) {
  if (!isColonies(colonies)) {
    stop("Argument colonies must be a Colonies class object!")
  }
  nCol <- nColonies(colonies)
  if (nCol == 0) {
    colonies <- createColonies()
  } else {
    for (colony in 1:nCol) {
      colonies@colonies[[colony]] <- supersedeColony(colonies[[colony]])
    }
  }
  return(colonies)
}

#' @rdname splitColonies
#' @title Split colony in two colonies for all given colonies
#'
#' @description The same as \code{\link{splitColony}} but for all given colonies.
#'
#' @param colonies \code{\link{Colonies-class}}
#' @param p numeric, percentage of workers that will go to the split colony
#'
#' @return list with two \code{\link{Colonies-class}}, the \code{splits} and the
#'   \code{remnants} (see the description what each colony holds!)
#'
#' @examples
#' founderGenomes <- quickHaplo(nInd = 3, nChr = 1, segSites = 100)
#' SP <- SimParamBee$new(founderGenomes)
#' basePop <- newPop(founderGenomes)
#'
#' drones <- createFounderDrones(pop = basePop[1], nDronesPerQueen = 10)
#' colony1 <- createColony(queen = basePop[2], fathers = drones[1:5])
#' (colony1 <- buildUpColony(colony1, nWorkers = 100))
#' colony2 <- createColony(queen = basePop[3], fathers = drones[6:10])
#' (colony2 <- buildUpColony(colony2, nWorkers = 100))
#' apiary <- c(colony1, colony2)
#' apiary
#' apiary[[1]]
#' apiary[[2]]
#'
#' tmp <- splitColonies(apiary)
#' tmp$split
#' tmp$split[[1]]
#' tmp$split[[2]]
#' tmp$remnant
#' tmp$remnant[[1]]
#' tmp$remnant[[2]]
#'
#' @export
splitColonies <- function(colonies, p = 0.3) {
  if (!isColonies(colony)) {
    stop("Argument colonies must be a Colonies class object!")
  }
  if (p < 0 | p > 1) {
    stop("pSplit must be between 0 and 1!")
  }
  nCol <- nColonies(colonies)
  if (nCol == 0) {
    ret <- list(splits = createColonies(n = 0),
                remnants = createColonies(n = 0))
  } else {
    ret <- list(splits = createColonies(n = nCol),
                remnants = createColonies(n = nCol))
    for (colony in 1:nCol) {
      tmp <- splitColony(colonies[[colony]], p = p)
      ret$splits@colonies[[colony]] <- tmp$split
      ret$remnants@colonies[[colony]] <- tmp$remnant
    }
  }
  return(ret)
}

#' @rdname setPhenoColonies
#' @title TODO
#'
#' @description
#'
#' @param colonies AlphaSimRBee Colonies object containing a list of colonies
#' @param FUN TODO
#' @param ... TODO
#'
#' @examples
#' TODO
#'
#' @return An updated AlphaSimRBee Colonies object
#'
#' @export
setPhenoColonies <- function(colonies, FUN = NULL, ...) {
  nCol <- nColonies(colonies)
  for (colony in 1:nCol) {
    colonies@colonies[[colony]] <- setPhenoColony(colonies[[colony]],
                                                  FUN = FUN, ...)
  }
  return(colonies)
}
